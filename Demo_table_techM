# The name of this view in Looker is "Demo Table"
view: demo_table {
  # The sql_table_name parameter indicates the underlying database table
  # to be used for all fields in this view.
  sql_table_name: "DEMO_SCH"."DEMO_TABLE" ;;

  # No primary key is defined for this view. In order to join this view in an Explore,
  # define primary_key: yes on a dimension that has no repeated values.

    # Here's what a typical dimension looks like in LookML.
    # A dimension is a groupable field that can be used to filter query results.
    # This dimension will be called "A Grp" in Explore.

  dimension: a_grp {
    type: string
    sql: ${TABLE}."A_GRP" ;;
  }

  dimension: a_prt {
    type: string
    sql: ${TABLE}."A_PRT" ;;
  }
  # Dates and timestamps can be represented in Looker using a dimension group of type: time.
  # Looker converts dates and timestamps to the specified timeframes within the dimension group.

  dimension: bkl_crdt {
    type: date
    sql: ${TABLE}."BKL_CRDT" ;;
  }

  dimension: crtpt_grpows {
    type: string
    sql: ${TABLE}."CRTPT_GRPOWS" ;;
  }

  dimension: f_aty_nm {
    type: string
    sql: ${TABLE}."F_ATY_NM" ;;
  }

  dimension: f_mt {
    type: number
    sql: ${TABLE}."F_MT" ;;
  }

  # A measure is a field that uses a SQL aggregate function. Here are defined sum and average
  # measures for this dimension, but you can also add measures of many different aggregates.
  # Click on the type parameter to see all the options in the Quick Help panel on the right.

  measure: total_f_mt {
    type: sum
    sql: ${f_mt} ;;
    }

  measure: average_f_mt {
    type: average
    sql: ${f_mt} ;;
    }

  dimension: f_pl {
    type: number
    sql: ${TABLE}."F_PL" ;;
  }

  dimension: f_qr_yr_nm {
    type: string
    sql: ${TABLE}."F_QR_YR_NM" ;;
  }

  dimension: f_smt {
    type: string
    sql: ${TABLE}."F_SMT" ;;
  }

  dimension: f_yr {
    type: date
    sql: ${TABLE}."F_YR" ;;
  }

  dimension: gd {
    type: string
    sql: ${TABLE}."GD" ;;
  }

  dimension: grs_r_am {
    type: number
    sql: ${TABLE}."GRS_R_AM" ;;
  }

  dimension: mc_ind_pl {
    type: string
    sql: ${TABLE}."MC_IND_PL" ;;
  }

  dimension: mt {
    type: string
    sql: ${TABLE}."MT" ;;
  }

  dimension: pb_d_grp {
    type: string
    sql: ${TABLE}."PB_D_GRP" ;;
  }

  dimension: pl {
    type: number
    sql: ${TABLE}."PL" ;;
  }

  dimension: pt_pr_grp_nms {
    type: string
    sql: ${TABLE}."PT_PR_GRP_NMS" ;;
  }

  dimension: r_grp_sty {
    type: string
    sql: ${TABLE}."R_GRP_STY" ;;
  }

  dimension: r_grpl_to_nm {
    type: string
    sql: ${TABLE}."R_GRPL_TO_NM" ;;
  }

  dimension: r_trx_sts {
    type: string
    sql: ${TABLE}."R_TRX_STS" ;;
  }

  dimension: r_ty {
    type: string
    sql: ${TABLE}."R_TY" ;;
  }

  dimension: rl_f_mt_os {
    type: number
    sql: ${TABLE}."RL_F_MT_OS" ;;
  }

  dimension: rl_f_q_os {
    type: number
    sql: ${TABLE}."RL_F_Q_OS" ;;
  }

  dimension: rl_f_yr_os {
    type: date
    datatype: date
    sql: ${TABLE}."RL_F_YR_OS" ;;
  }

  dimension: sl_grp {
    type: string
    sql: ${TABLE}."SL_GRP" ;;
  }

  dimension: sl_sg_g_nm_s {
    type: string
    sql: ${TABLE}."SL_SG_G_NM_S" ;;
  }

  dimension: sl_sg_i_1_nm_s {
    type: string
    sql: ${TABLE}."SL_SG_I_1_NM_S" ;;
  }

  dimension: sl_sg_i_2_nm_s {
    type: string
    sql: ${TABLE}."SL_SG_I_2_NM_S" ;;
  }

  dimension: ssg_lb {
    type: number
    sql: ${TABLE}."SSG_LB" ;;
  }

  dimension: un_pb_nm {
    type: string
    sql: ${TABLE}."UN_PB_NM" ;;
  }

  dimension: xd_fl {
    type: string
    sql: ${TABLE}."XD_FL" ;;
  }

  dimension_group: yr {
    type: time
    timeframes: [raw, date, week, month, quarter, year]
    convert_tz: no
    datatype: date
    sql: ${TABLE}."YR" ;;
  }
  measure: count {
    type: count
  }
  dimension: Current_WTD {
    type: string
    sql:
    CASE
      WHEN ${bkl_crdt} >= DATE_TRUNC(WEEK, CURRENT_DATE())
      AND ${bkl_crdt} <= CURRENT_DATE()
      THEN ${f_pl}
    END ;;
  }
  dimension: FS_MT_N {
    type: string  # Adjust the type if it's a number, date, etc.
    sql: ${TABLE}.f_smt ;;
  }
  dimension: FS_MT_SM {
    type: string  # Adjust the type if it's a number, date, etc.
    sql: ${TABLE}.f_smt ;;
  }
  dimension: ML1S {
    type: string
    sql:
    CASE
      -- First case: F Yr = 2024, F Mt >= 4, and Sl Sg I 1 Nm S = 'RG'
      WHEN ${f_yr} = 2024 AND ${f_mt} >= 4 AND UPPER(${sl_sg_i_1_nm_s}) = 'RG' THEN
        CASE
          WHEN NOT IS_NULL(${pt_pr_grp_nms}) AND UPPER(${pt_pr_grp_nms}) IN ('CR', 'TW', 'TWV', 'GC', 'NR', 'DRW') THEN 'QD'
          WHEN NOT IS_NULL(${pt_pr_grp_nms}) AND UPPER(${pt_pr_grp_nms}) IN ('GE', 'HB') THEN 'VC'
          WHEN IS_NULL(${pt_pr_grp_nms}) THEN 'UNCL'
          WHEN NOT IS_NULL(${pt_pr_grp_nms}) AND UPPER(${pt_pr_grp_nms}) = 'TW' THEN 'TWT'
          ELSE ${sl_sg_i_1_nm_s}
        END

      -- Second case: Sl Sg I 1 Nm S = 'RD' and Pt Pr Grp Nms = 'TW'
      WHEN UPPER(${sl_sg_i_1_nm_s}) = 'RD' AND NOT IS_NULL(${pt_pr_grp_nms}) AND UPPER(${pt_pr_grp_nms}) = 'TW' THEN 'TWT'

      -- Third case: F Yr = 2023, F Mt >= 4, and Sl Sg I 1 Nm S = 'RG'
      WHEN ${f_yr} = 2023 AND ${f_mt} >= 4 AND UPPER(${sl_sg_i_1_nm_s}) = 'RG' THEN
        CASE
          WHEN NOT IS_NULL(${pt_pr_grp_nms}) AND UPPER(${pt_pr_grp_nms}) IN ('CR', 'TW', 'TWV', 'GC', 'NR', 'DRW') THEN 'QD'
          WHEN NOT IS_NULL(${pt_pr_grp_nms}) AND UPPER(${pt_pr_grp_nms}) IN ('GE', 'HB') THEN 'VC'
          ELSE ${sl_sg_i_1_nm_s}
        END

      -- Default case: return Sl Sg I 1 Nm S
      ELSE ${sl_sg_i_1_nm_s}
      END ;;
  }
  dimension: PN {
    type: string
    sql:
    CASE
      WHEN ${rl_f_mt_os} IN (1, -11, 13) THEN 'YES'
      ELSE 'NO'
    END ;;
  }
  dimension: PT {
    type: string
    sql:
    CASE
      WHEN ${rl_f_mt_os} IN (0, -12, 12) THEN 'YES'
      ELSE 'NO'
    END ;;
  }
  dimension: PT_PR_GR {
    type: string  # Change the type if it's not a string (e.g., number, date)
    sql: ${TABLE}.sl_sg_i_2_nm_s ;;
  }
  dimension: PT2 {
    type: string
    sql:
    CASE
      WHEN ${rl_f_q_os} IN (0, -4, 4) THEN 'YES'
      ELSE 'NO'
    END ;;
  }
  dimension: PT3 {
    type: string
    sql:
    CASE
      WHEN ${rl_f_yr_os} IN (0, -1, 1) THEN 'YES'
      ELSE 'NO'
    END ;;
  }
  dimension: R_AType {
    type: string
    sql:
    CASE
      WHEN ${xd_fl} = 'Y' THEN 'XD'
      ELSE ${r_ty}
    END ;;
  }
  dimension: R_PL_GRP {
    type: string
    sql: ' ' ;;
  }
  dimension: RDIM_M {
    type: string
    sql:
    CASE
      WHEN ${sl_grp} = 'MCA' THEN NULL
      WHEN ${sl_grp} = 'CNT' THEN 'LLB'
      ELSE NULL  -- Optional: specify a default case if needed
    END ;;
  }
  dimension: SD_FL {
    type: yesno  # Use 'yesno' if you want the output as TRUE/FALSE
    sql:
    CASE
      WHEN NOT ${un_pb_nm} IN ('ABC', 'DEF', 'GHI', 'JKL')
           OR (${un_pb_nm} IN ('DEF', 'HIJ', 'NOP', 'KLM')
           AND ${a_grp} IN ('CWH', 'TGG')) THEN TRUE
      ELSE FALSE
    END ;;
  }
  dimension: SL_SG_G_NM_S_GRP {
    type: string
    sql: ' ' ;;
  }
  dimension: SND_PB_FL {
    type: string
    sql: ' ' ;;
  }
  measure: B+F_PL {
    type: number
    sql: SUM(${TBK_IFR}) + SUM(${FRF_CNT}) ;;
  }
  measure: BK_SL_PL_to_BD_% {
    type: number
    sql: (CO${BKSL_PL}, 0) / NULLIF(SUM(${sb ty}), 0)) ;;
  }
  measure: BK_SL_PL_to_BD_$ {
    type: number
    sql: ${BKSL_PL} - SUM(${SB_TY}) ;;
  }
  measure: BKSL_PL {
    type: number
    sql: SUM(${TBK_IFR}) + SUM(${SL_PL}) ;;
  }
  measure: FRF_CNT {
    type: number
    sql:
    CASE
      WHEN MAX(${sl_sg_i_2_nm_s}) = 'DO' AND SUM(${PL_D}) > 0 THEN SUM(${PL_D}) - SUM(${TBK_IFR})
      WHEN SUM(${PL_D}) - SUM(${TBK_IFR}) > 0 THEN SUM(${PL_D}) - SUM(${TBK_IFR})
      ELSE 0
    END ;;
  }
  measure: Last_LR_F {
    type: number  # Change to dimension if necessary
    sql:
    CASE
      WHEN ${rl_f_yr_os} = -1 THEN ${grs_r_am}
      ELSE 0
    END ;;
  }
  measure: LR_for_PC {
    type: number  # Change to dimension if necessary
    sql:
    CASE
      WHEN ${rl_f_mt_os} > -1 THEN ${Last_LR_F}
      ELSE NULL  -- Optional: specify a value if needed for the else case
    END ;;
  }
  measure: Next {
    type: number  # Change to dimension if needed
    sql:
    CASE
      WHEN ${rl_f_yr_os} = 1 THEN ${TBK}
      ELSE 0
    END ;;
  }
  measure: PL_D {
    type: number  # Change to dimension if needed
    sql: ${pl} / 1000 ;;
  }
  measure: SB_TY {
    type: number  # Change to dimension if needed
    sql:
    CASE
      WHEN ${rl_f_yr_os} = 0 THEN ${ssg_lb} / 1000
      ELSE 0
    END ;;
  }
  measure: SL_BKD_%_of_BD {
    type: number  # This can be changed to dimension if needed
    sql:
    COALESCE(SUM(${Last_LR_F}), 0) / NULLIF(COALESCE(SUM(${ssg_lb}), 0), 0) ;;
  }
  measure: SL_BKD_BD {
    type: number  # Change to dimension if needed
    sql: ${TBK_IFR} - ${SB_TY} ;;
  }
  measure: SL_LB_for_PC {
    type: number  # Change to dimension if needed
    sql:
    CASE
      WHEN ${rl_f_mt_os} > -1 THEN ${ssg_lb}
      ELSE NULL  # Returns NULL if the condition is not met
    END ;;
  }
# Measure to calculate the difference between PL D and TBK IFR
  measure: pl_d_minus_tbk_ifr {
    type: number
    sql: ${PL_D} - ${TBK_IFR} ;;
  }
# Main measure implementing the logic
  measure: SL_PL {
    type: number
    sql:
    CASE
      WHEN MAX(${sl_sg_i_2_nm_s}) = 'DO' AND SUM(${PL_D}) > 0 THEN SUM(${pl_d_minus_tbk_ifr})
      WHEN SUM(${pl_d_minus_tbk_ifr}) > 0 THEN SUM(${pl_d_minus_tbk_ifr})
      ELSE 0
    END ;;
  }
  measure: TBK {
    type: number  # Change to dimension if needed
    sql: ${grs_r_am} / 1000 ;;
  }
  measure: TBK_IFR {
    type: number
    sql:
    CASE
      WHEN ${rl_f_yr_os} = 0 THEN ${TBK}
      ELSE 0
    END ;;
  }
  measure: TY_LR-FW_QS {
    type: number
    sql:
    CASE
      WHEN ${rl_f_yr_os} = 0 AND ${rl_f_q_os} >= 0 THEN ${grs_r_am}
      ELSE NULL
    END ;;
  }
  measure: TY_LR_F {
    type: number
    sql:
    CASE
      WHEN ${rl_f_yr_os} = 0 THEN ${grs_r_am}
      ELSE 0
    END ;;
  }
}
